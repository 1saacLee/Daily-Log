## OpenGL的光照

在讨论光照之前，我们需要先思考颜色的产生。在太阳光的照射下，不同的物体会吸收不同颜色的光，其余不被吸收的光经过反射照到我们的眼睛中，就会看到不同颜色的物体。如果我们使用的不是太阳光（白光），而是某种其他颜色的光（例如红光，紫光），那么物体就只能反射出该颜色的光。
因此，我们可以用向量的点乘来表示颜色

### 不透明物体的颜色

- 定义光照颜色、物体本身的反射特性，实际呈现的颜色为：
    ```
    glm::vec3 lightColor(0.33f, 0.42f, 0.18f);
    glm::vec3 toyColor(1.0f, 0.5f, 0.31f);
    glm::vec3 result = lightColor * toyColor; // = (0.33f, 0.21f, 0.06f);
    ```

### Phong模型

Phong模型认为光照可以分为三个部分：环境光照、漫反射光照以及高光反射光照。
- 环境光照认为任何环境都不是纯黑的，任何物体都不能完全吸收光，因此环境光照可以永远给物体一个颜色

- 漫反射认为粗糙的物体可以在一个相当大的范围内反射入射光，虽然看起来并不那么亮

- 高光反射就是镜面反射，Phong模型认为任何物体都存在镜面反射与漫反射，不同材质的区别只在于他们的反射强度不同。镜面反射相当亮，而且范围相当小


### 环境光照

环境光照的实现非常简单，就是将一个很小的常量乘以物体本身的颜色，使得这个物体并不是全黑的：

```
// Fragment Shader

void main()
{
    float ambientStrength = 0.1;
    vec3 ambient = ambientStrength * lightColor;

    vec3 result = ambient * objectColor;
    FragColor = vec4(result, 1.0);
}
```

### 漫反射光照

漫反射的实现核心代码如下：
```
float diff = max(dot(norm, lightDir), 0.0);
vec3 diffuse = diff * lightColor;
```

这里，`norm`是某个平面的法向量，`lightDir`是入射光的方向，为了防止出现这两个向量乘积为负的情况，使用`max`将结果规整到大于零的范围内。

- 从这里也可以看到，一个平面内的所有点，都共享同一个法向量，因此他们的颜色是一模一样的，也就是说漫反射只在不同平面上有区别，个人认为这是与实际情况可能会有出入的一个做法，特别是当平面特别大的时候。

除了刚才提到的两行核心代码以外，OpenGL实现漫反射的大部分工作都在进行坐标的变换以及传参，例如法向量的计算：
```
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos - FragPos);
```
在此就不再赘述了

### 镜面反射


镜面反射与漫反射最大的不同在于，他的强度除了与光照和平面的方向有关，还和观察者所处的位置有关。刚才提到，一旦某个平面和光源的位置确定，漫反射的强度就可以立马计算得到，而镜面反射还需要考虑观察者的位置，如果观察者在反射方向上，或者离反射方向非常接近的话，那么镜面反射的强度就会非常强；否则，强度就会非常弱。

因此，向量初始定义的时候，我们会额外定义一个反射方向向量以及观察者位置向量
```
vec3 viewDir = normalize(viewPos - FragPos);
vec3 reflectDir = reflect(-lightDir, norm);
```


计算镜面反射的核心代码为：
```
float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);
vec3 specular = specularStrength * spec * lightColor;
```
这里，我们计算了视线方向与反射方向的点乘，然后又取了他的32次幂，这种乘方的操作就会放大镜面反射的非线性


## 为什么在Fragment Shader里进行光照计算

这是一个很有意思的问题，刚才说过，漫反射和镜面反射与平面的法向量有关，如果在Vertex Shader里计算，就只能得到每个顶点的光照值，至于平面上点的光照，就只能通过插值的方法得到，因此会显得比较不真实，镜面反射尤为明显